#! /usr/bin/env python

import sys
import os, os.path
from os.path import expanduser

import time
import argparse
from argparse import ArgumentDefaultsHelpFormatter
import csv

MAXWIDTH = 8 # Allow for about 100 M ticketses

'''
Type: List
Table: Task [task] (because 'My Work' is about tasks

Green means you already have it.
Nothing is red is either available or interesting.

 0 Number
 1 Created
 2 Short Description
 3 Assignment group
 4 Assigned to
 5 Caller
 6 Solution (Customer View)
 7 GGUS ID
 8 Description
 9 Close notes (Internal View)
10 Additional comments (Customer View)
11 Work notes (Internal View)

'Updated by' could be useful if can search for our whole group

Assigment group is javascript:getMyGroups()
'''

def mkix(args):
    from whoosh.index import create_in
    from whoosh.fields import Schema, TEXT

    # RC dir
    indexpath = args.rcdir + '/index'
    if not os.path.isdir(args.rcdir):
        os.mkdir(args.rcdir)
    if not os.path.isdir(indexpath):
        os.mkdir(indexpath)

    # Whoosh schema
    schema = Schema(number=TEXT(stored=True),
                    shortdesc=TEXT(stored=True),
                    solution=TEXT(stored=True),
                    desc=TEXT(stored=True),
                    closenotes=TEXT(stored=True),
                    comments=TEXT(stored=True),
                    worknotes=TEXT(stored=True),
                   )
    ix = create_in(indexpath, schema)

    # Index CSV rows
    writer = ix.writer()
    with open(args.csvfile) as f:
        reader = csv.reader(f)
        reader.next() # Skip header

        t0 = time.time()
        for i, row in enumerate(reader, 1):
            writer.add_document(number=unicode(row[0]),
                                shortdesc=row[2].decode('latin-1'),
                                solution=row[6].decode('latin-1'),
                                desc=row[8].decode('latin-1'),
                                closenotes=row[9].decode('latin-1'),
                                comments=row[10].decode('latin-1'),
                                worknotes=row[11].decode('latin-1'),
                               )
            if i % 50 == 0:
                print "Indexing %%0%dd ticketses\r" % MAXWIDTH % i,
                sys.stdout.flush()
        print "Indexing %%0%dd\n" % MAXWIDTH % i,
        print "Committing..."
        writer.commit()
        print "Indexed %d ticketses in %.2f s" % (i, time.time() - t0)

def ls(args):
    with open(args.csvfile) as f:
        reader = csv.reader(f)
        reader.next() # Skip header
        for row in reader:
            print "%% %ds %%s" % (MAXWIDTH + 4) % (row[0], row[2])

def search(args):
    from whoosh.index import open_dir
    from whoosh.qparser import MultifieldParser

    indexpath = args.rcdir + '/index'
    ix = open_dir(indexpath)
    with ix.searcher() as searcher:
        # Build query
        parser = MultifieldParser(['shortdesc', 'solution', 'desc',
                                   'closenotes', 'comments', 'worknotes'],
                                  ix.schema)
        query = parser.parse(unicode(' '.join(args.keyword)))

        # Search and display ticketses
        results = searcher.search(query, limit=None)
        for r in results:
            print "%% %ds %%s" % (MAXWIDTH + 4) % (r['number'], r['shortdesc'])

        # Report
        print
        print "Found about %d matching ticketses in %.2f s" % \
            (results.estimated_length(), results.runtime)

def main():
    p = argparse.ArgumentParser(formatter_class=ArgumentDefaultsHelpFormatter)
    p.add_argument('--csvfile', type=expanduser, help="SNOW CSV file",
                   default='~/Me Own Knowledge Base.csv')
    p.add_argument('--rcdir', type=expanduser, help="runtime config dir",
                   default='~/.snowplough')
    subs = p.add_subparsers()

    pl = subs.add_parser('ls', help="list ticketses")
    pl.set_defaults(func=ls)

    pm = subs.add_parser('mkix', help='make index')
    pm.set_defaults(func=mkix)

    ps = subs.add_parser('search', help='search ticketses')
    ps.add_argument('keyword', nargs='+')
    ps.set_defaults(func=search)

    args = p.parse_args()
    args.func(args)

if __name__ == '__main__':
    sys.exit(main())
