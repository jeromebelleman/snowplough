#! /usr/bin/env python

import sys
reload(sys)
sys.setdefaultencoding('utf-8')
import os, os.path
from os.path import expanduser
import subprocess
from datetime import datetime

import time
import argparse
from argparse import ArgumentDefaultsHelpFormatter

INC = "https://foo.service-now.com/service-portal/view-incident.do?n="
RQF = "https://foo.service-now.com/service-portal/view-request.do?n="
TIMEINFMT = '%d-%m-%Y %H:%M:%S %Z'
TIMEOUTFMT = '%Y-%m-%d'
MAXWIDTH = 11 # Allow for about 100 M ticketses
DATEWIDTH = 10
ASSIGNEEWIDTH = 15
GROUPWIDTH = 15

VIMCMDS = [
           '+set fdm=marker ic',
           '+sy region snowHead start=/^\d\d-\d\d-\d\{4\}/ end=/View))\?/',
           '+hi link snowHead String',
          ]

# TODO Remove explicit unicode functions?

'''
Type: List
Table: Task [task] (because 'My Work' is about tasks

Green means you already have it.
Nothing is red is either available or interesting.

 0 Number
 1 Created
 2 Short Description
 3 Assignment group
 4 Assigned to
 5 Caller
   Solution (Customer View) -- Solution is in comments too
 6 GGUS ID
 7 Description
 8 Close notes (Internal View)
 9 Additional comments (Customer View)
10 Work notes (Internal View)

'Updated by' could be useful if can search for our whole group

Assigment group is javascript:getMyGroups()
'''

def shortdescwidth():
    out, _ = subprocess.Popen(['stty', 'size'],
                              stdout=subprocess.PIPE).communicate()
    _, w = out.split()

    return int(w) - MAXWIDTH - 4 - DATEWIDTH - ASSIGNEEWIDTH - GROUPWIDTH

def mkix(args):
    import zipfile, csv
    from whoosh.index import create_in
    from whoosh.fields import Schema, TEXT, DATETIME

    # RC dir
    indexpath = args.rcdir + '/index'
    if not os.path.isdir(args.rcdir):
        os.mkdir(args.rcdir)
    if not os.path.isdir(indexpath):
        os.mkdir(indexpath)

    # Whoosh schema
    schema = Schema(number=TEXT(stored=True),
                    created=DATETIME(stored=True),
                    shortdesc=TEXT(stored=True),
                    group=TEXT(stored=True),
                    assignee=TEXT(stored=True),
                    # solution=TEXT(stored=True), # Solution is in comments too
                    desc=TEXT(stored=True),
                    closenotes=TEXT(stored=True),
                    comments=TEXT(stored=True),
                    worknotes=TEXT(stored=True),
                   )
    ix = create_in(indexpath, schema)

    # Index CSV rows
    writer = ix.writer()
    try:
        z = zipfile.ZipFile(args.snowfile)
        f = z.open(args.csvname)
    except zipfile.BadZipfile:
        f = open(args.snowfile)

    try:
        reader = csv.reader(f)
        reader.next() # Skip header

        t0 = time.time()
        for i, row in enumerate(reader, 1):
            writer.add_document(number=unicode(row[0]),
                                created=datetime.strptime(row[1], TIMEINFMT),
                                shortdesc=row[2].decode('latin-1'),
                                group=row[3].decode('latin-1'),
                                assignee=row[4].decode('latin-1'),
                                # solution=row[6].decode('latin-1'),
                                desc=row[7].decode('latin-1'),
                                closenotes=row[8].decode('latin-1'),
                                comments=row[9].decode('latin-1'),
                                worknotes=row[10].decode('latin-1'),
                               )
            if not args.quiet and i % 50 == 0:
                print "Indexing %%0%dd ticketses\r" % (MAXWIDTH - 3) % i,
                sys.stdout.flush()
        if not args.quiet:
            print "Indexing %%0%dd\n" % (MAXWIDTH - 3) % i,
            print "Committing..."
        writer.commit()
        if not args.quiet:
            print "Indexed %d ticketses in %.2f s" % (i, time.time() - t0)
        
    except KeyboardInterrupt:
        pass

def vim(f, result):
    print >>f, "{{{ %s %s" % (result['number'], result['shortdesc'])
    print >>f, '%s -- %s, %s' % (result['created'].strftime(TIMEOUTFMT),
                                 result['assignee'],
                                 result['group'],
                                )
    if result['number'][:3] == 'INC':
        print >>f, INC + result['number']
    else: 
        print >>f, RQF + result['number']

    for k, l in zip(('desc', 'closenotes', 'comments', 'worknotes'),
                    ('Description', 'Close Notes', 'Comments', 'Work Notes')):
        if result[k]:
            print >>f, "{{{ " + l
            print >>f, result[k].replace('\r', '')
            print >>f, "}}}"

    print >>f, "}}}"

def search(args):
    import tempfile, codecs
    from whoosh.index import open_dir

    indexpath = args.rcdir + '/index'
    ix = open_dir(indexpath)
    with ix.searcher() as searcher:
        # Build query
        if args.keyword == ['*']: # Just list
            from whoosh.qparser import QueryParser
            parser = QueryParser('number', ix.schema)
        else:
            from whoosh.qparser import MultifieldParser
            from whoosh.qparser.dateparse import DateParserPlugin

            parser = MultifieldParser(['shortdesc', 'desc',
                                       'closenotes', 'comments', 'worknotes'],
                                      ix.schema)
            parser.add_plugin(DateParserPlugin(basedate=datetime.now(),
                                               free=True))
        query = parser.parse(unicode(' '.join(args.keyword)))

        # Start Vim
        if args.vim:
            # FIXME Should be in user directory in /tmp
            f = tempfile.NamedTemporaryFile(suffix='-snowplough')
            uf = codecs.open(f.name, 'w', 'utf-8')

        # Search and display ticketses
        if args.sort:
            results = searcher.search(query, limit=None, sortedby='created')
        else:
            results = searcher.search(query, limit=None)

        if not args.vim:
            sdw = shortdescwidth()
        for r in results:
            if args.vim:
                vim(uf, r)
            else:
                print "%% %ds %%s %% %ds %% %ds %%s" % \
                    (MAXWIDTH, ASSIGNEEWIDTH, GROUPWIDTH) % \
                    (r['number'],
                     r['created'].strftime(TIMEOUTFMT),
                     r['assignee'][:ASSIGNEEWIDTH],
                     r['group'][:GROUPWIDTH],
                     r['shortdesc'][:sdw])

        if args.vim:
            f.flush()
            subprocess.call(['vim'] + VIMCMDS + [f.name])

        # Report
        print >>sys.stderr
        print >>sys.stderr, "Found about %d matching ticketses in %.2f s" % \
            (results.estimated_length(), results.runtime)

def main():
    p = argparse.ArgumentParser(formatter_class=ArgumentDefaultsHelpFormatter)
    p.add_argument('--rcdir', type=expanduser, help="runtime config dir",
                   default='~/.snowplough')
    subs = p.add_subparsers()

    # mkix sub-command
    pm = subs.add_parser('mkix', help="make index")
    pm.add_argument('snowfile', help="SNOW report zip or CSV file",
                    type=expanduser)
    pm.add_argument('--csvname', help="SNOW CSV name in zip file",
                    default='Me Own Knowledge Base.csv')
    pm.add_argument('--quiet', action='store_true',
                    help="don't print out anything")
    pm.set_defaults(func=mkix)

    # search sub-command
    ps = subs.add_parser('search', help="search ticketses")
    h = '''case-insensitive, supports wildcards and fuzzy dates
           (e.g. vom\* created:1 apr to 6 apr 2012)'''
    ps.add_argument('keyword', nargs='+', help=h)
    ps.add_argument('--sort', action='store_true', help='sort by creation time')
    ps.add_argument('--vim', action='store_true', help='display in Vim')
    ps.set_defaults(func=search)

    # Parse arguments
    args = p.parse_args()
    args.func(args)

if __name__ == '__main__':
    sys.exit(main())
